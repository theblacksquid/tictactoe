// Generated by CoffeeScript 1.10.0
(function() {
  var App, Cell, Grid, MainModal, Row, SelectModal, ai, box_path, didPlayerWin, evalGame, flatten, game, getCurrentState, getRandInt, getX, getY, lineFromGrid, lineLength, menu, o_path, pointsEq, ptIndex, ptsAroundpt, slope, x_path;

  getX = function(pt) {
    return pt[0];
  };

  getY = function(pt) {
    return pt[1];
  };

  slope = function(point1, point2) {
    switch (false) {
      case (getY(point1) - getY(point2)) !== 0:
        return 'VERTICAL';
      case (getX(point1) - getX(point2)) !== 0:
        return 'HORIZONTAL';
      default:
        return (getY(point1) - getY(point2)) / (getX(point1) - getX(point2));
    }
  };

  lineFromGrid = function(grid, direction, start) {
    var cache, i, j, len1, length, row;
    length = grid.length;
    cache = [];
    i = start;
    switch (false) {
      case direction !== 'HORIZONTAL':
        return grid[start];
      case direction !== 'VERTICAL':
        for (j = 0, len1 = grid.length; j < len1; j++) {
          row = grid[j];
          cache.push(row[start]);
        }
        return cache;
      case direction !== 'DIAGONAL':
        while (length > i) {
          cache.push(grid[i][i]);
          i++;
        }
        return cache;
      case direction !== 'ANTI-DIAG':
        while (length > i) {
          cache.push(grid[i][(length - 1) - i]);
          i++;
        }
        return cache;
    }
  };

  pointsEq = function(lineArr) {
    var i;
    i = 0;
    while (lineArr.length > i) {
      if (lineArr[i] !== lineArr[0]) {
        return false;
      }
      i++;
    }
    return true;
  };

  flatten = function(arr) {
    return [].concat.apply([], arr);
  };

  lineLength = function(lineArr, ptval) {
    if (pointsEq(lineArr)) {
      return lineArr.length;
    } else {
      return lineArr.filter(function(x) {
        if (x === ptval) {
          return true;
        }
      }).length;
    }
  };

  ptIndex = function(grid, ptval) {
    var cell, j, k, len1, len2, result, row, x, y;
    result = [];
    x = 0;
    for (j = 0, len1 = grid.length; j < len1; j++) {
      row = grid[j];
      y = 0;
      for (k = 0, len2 = row.length; k < len2; k++) {
        cell = row[k];
        if (cell === ptval) {
          result.push([x, y]);
          y++;
        } else {
          y++;
        }
      }
      x++;
    }
    return result;
  };

  getRandInt = function(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  };

  ptsAroundpt = function(pos) {
    var dir, directions, dx, dy, j, len1, result, x, y;
    x = getX(pos);
    y = getY(pos);
    directions = [[-1, 0], [-1, -1], [0, -1], [1, -1], [1, 0], [1, 1], [0, 1], [-1, 1]];
    result = [];
    for (j = 0, len1 = directions.length; j < len1; j++) {
      dir = directions[j];
      dx = getX(dir);
      dy = getY(dir);
      result.push([x + dx, y + dy]);
    }
    return result;
  };

  didPlayerWin = function(player, gamestate) {
    var anti, arr, diag, horiz, i, item, j, len1, vert;
    i = 0;
    while (gamestate.length > i) {
      horiz = lineFromGrid(gamestate, "HORIZONTAL", i);
      vert = lineFromGrid(gamestate, "VERTICAL", i);
      diag = lineFromGrid(gamestate, "DIAGONAL", 0);
      anti = lineFromGrid(gamestate, "ANTI-DIAG", 0);
      arr = [horiz, vert, diag, anti];
      for (j = 0, len1 = arr.length; j < len1; j++) {
        item = arr[j];
        if ((pointsEq(item) === true) && (item[0] === player)) {
          return true;
        }
      }
      i++;
    }
    return false;
  };

  evalGame = function(gamestate, player1, player2) {
    var cells, non_null;
    non_null = flatten(gamestate).filter(function(x) {
      if (x !== "unclaimed") {
        return true;
      }
    });
    cells = flatten(gamestate).length;
    if (didPlayerWin(player1, gamestate)) {
      return player1 + " wins";
    } else if (didPlayerWin(player2, gamestate)) {
      return player2 + " wins";
    } else if (non_null.length === cells) {
      return "DRAW";
    } else {
      return "CONTINUE";
    }
  };

  getCurrentState = function(grid) {
    var cache, cell, j, k, len1, len2, ref, row, rows, state;
    rows = grid.rows;
    state = [];
    for (j = 0, len1 = rows.length; j < len1; j++) {
      row = rows[j];
      cache = [];
      ref = row.cells;
      for (k = 0, len2 = ref.length; k < len2; k++) {
        cell = ref[k];
        cache.push(cell.status);
      }
      state.push(cache);
    }
    return state;
  };

  game = {};

  game.state = [];

  game.turns = 1;

  game.over = function(grid) {
    var cell, j, k, len1, len2, ref, ref1, row;
    ref = grid.rows;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      row = ref[j];
      ref1 = row.cells;
      for (k = 0, len2 = ref1.length; k < len2; k++) {
        cell = ref1[k];
        $("#cell-" + cell.row + "-" + cell.col + "-img").off();
      }
    }
    return game.turns = 1;
  };

  game.players = {
    human: "",
    ai: ""
  };

  game.obj = {};

  game.main = function(parent, num) {
    var cell, grd, isState, j, k, len1, len2, ref, ref1, row;
    grd = new Grid(parent, num);
    grd.render();
    game.state = getCurrentState(grd);
    isState = "CONTINUE";
    ref = grd.rows;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      row = ref[j];
      ref1 = row.cells;
      for (k = 0, len2 = ref1.length; k < len2; k++) {
        cell = ref1[k];
        $("#cell-" + cell.row + "-" + cell.col + "-img").click(function() {
          var newGame, result;
          game.state = getCurrentState(grd);
          result = evalGame(game.state, "X", "O");
          if (result !== "CONTINUE") {
            game.over(grd);
            $("#status").html("Tic Tac Toe | " + result);
            newGame = new SelectModal("#leftmenu");
            newGame.render();
          }
          return ai.respond(grd);
        });
      }
    }
    game.state = getCurrentState(grd);
    return ai.respond(grd);
  };

  o_path = 'icons/ic_block_black_24dp/web/ic_block_black_24dp_2x.png';

  x_path = 'icons/ic_clear_black_24dp/web/ic_clear_black_24dp_2x.png';

  box_path = 'icons/ic_crop_din_black_24dp/web/ic_crop_din_black_24dp_2x.png';

  Cell = (function() {
    function Cell(el, col, row1) {
      this.el = el;
      this.col = col;
      this.row = row1;
      this.status = 'unclaimed';
      this.id = "cell-" + this.row + "-" + this.col;
    }

    Cell.prototype.template = function() {
      return "        <div class='cell' id='cell-" + this.row + "-" + this.col + "' style='display: inline-block'>\n	<img id='cell-" + this.row + "-" + this.col + "-img' src='" + box_path + "' />\n</div>";
    };

    Cell.prototype.render = function() {
      $(this.el).append(this.template());
      return this.onClick();
    };

    Cell.prototype.onClick = function() {
      var self;
      self = this;
      return $("#cell-" + this.row + "-" + this.col + "-img").click(function() {
        if (self.status === 'unclaimed') {
          if ((game.turns % 2) === 0) {
            self.status = 'O';
            $("#cell-" + self.row + "-" + self.col + "-img").attr("src", o_path);
            return game.turns++;
          } else {
            self.status = 'X';
            $("#cell-" + self.row + "-" + self.col + "-img").attr("src", x_path);
            return game.turns++;
          }
        } else {
          return console.log("claimed cell clicked");
        }
      });
    };

    return Cell;

  })();

  Row = (function() {
    function Row(el, rownum, numcells) {
      this.el = el;
      this.rownum = rownum;
      this.numcells = numcells;
      this.cells = [];
      this.id = "row-" + this.rownum;
    }

    Row.prototype.template = function() {
      return "<div id='row-" + this.rownum + "'>\n</div>";
    };

    Row.prototype.render = function() {
      $(this.el).append(this.template());
      return this.generateCells(this.numcells);
    };

    Row.prototype.generateCells = function(cellnums) {
      var cell, i, results;
      i = 0;
      results = [];
      while (cellnums > i) {
        cell = new Cell("#row-" + this.rownum, this.rownum, i);
        this.cells.push(cell);
        cell.render();
        results.push(i++);
      }
      return results;
    };

    return Row;

  })();

  Grid = (function() {
    function Grid(el, numrows) {
      this.el = el;
      this.numrows = numrows;
      this.rows = [];
    }

    Grid.prototype.template = function() {
      return "<div id='game-grid'>\n</div>";
    };

    Grid.prototype.render = function() {
      $(this.el).html(this.template());
      return this.generateRows(this.numrows);
    };

    Grid.prototype.generateRows = function(rownums) {
      var i, results, row;
      i = 0;
      results = [];
      while (rownums > i) {
        row = new Row("#game-grid", i, rownums);
        this.rows.push(row);
        row.render();
        results.push(i++);
      }
      return results;
    };

    return Grid;

  })();

  SelectModal = (function() {
    function SelectModal(el) {
      this.el = el;
    }

    SelectModal.prototype.template = function() {
      return "<div class='w3-container'>\n	<div class='w3-row'>\n		<div class='w3-container w3-half'>\n			<input type='image' id='choose-x' src='" + x_path + "' class='w3-hover-light-gray' /> <br />\n			Go First\n		</div>\n		<div class='w3-container w3-half'>\n			<input type='image' id='choose-o' src='" + o_path + "' class='w3-hover-light-gray' /> <br />\n			Go Second\n		</div>\n	</div>\n</div>";
    };

    SelectModal.prototype.render = function() {
      $(this.el).html(this.template());
      return this.chooseTurn();
    };

    SelectModal.prototype.chooseTurn = function() {
      var self;
      self = this;
      $('#choose-x').click(function() {
        var main;
        game.players.human = "X";
        game.players.ai = "O";
        main = new MainModal("#leftmenu");
        return main.render();
      });
      return $('#choose-o').click(function() {
        var main;
        game.players.human = "O";
        game.players.ai = "X";
        main = new MainModal("#leftmenu");
        return main.render();
      });
    };

    return SelectModal;

  })();

  MainModal = (function() {
    function MainModal(el) {
      this.el = el;
    }

    MainModal.prototype.template = function() {
      return "<div>\n	<input id='menu-val' type='text' placeholder='Number of Rows' class='w3-input w3-border w3-hover-light-grey'/> <br />\n	<button id='menu-btn' class='w3-btn-block'>START</button> \n	<br />\n	<p>Indicate the number of rows you want the\n	game's grid to have, and it will create\n	a grid that has that number of rows squared\n	amount of cells. A minimum of 3 is required.</p>\n</div>";
    };

    MainModal.prototype.render = function() {
      $(this.el).html(this.template());
      return this.onStart();
    };

    MainModal.prototype.onStart = function() {
      return $("#menu-btn").click(function() {
        if ($("#menu-val").val() < 3) {
          $("#status").html("Tic Tac Toe | A minimum of three rows are required");
          console.log($("#menu-val").val());
        } else {

        }
        game.main("#game", $("#menu-val").val());
        $("#status").html("Tic Tac Toe |");
        $('#menu-btn').off();
        return console.log($("#menu-val").val() + " proper");
      });
    };

    return MainModal;

  })();

  App = (function() {
    function App(el) {
      this.el = el;
    }

    App.prototype.template = function() {
      return "<div class='w3-container'>\n	<div class='w3-container w3-black'>\n		<h2 id='status'>Tic Tac Toe | </h2>\n	</div>\n	<div id='main-screen' class='w3-container w3-row'>\n		<div id='leftmenu' class='w3-container w3-third' style='padding-top: 16px'>\n		</div>\n		<div id='game' class='w3-container w3-rest w3-center'>\n		</div>\n	</div>\n</div>";
    };

    App.prototype.render = function() {
      var leftmenu;
      $(this.el).html(this.template());
      leftmenu = new SelectModal("#leftmenu");
      return leftmenu.render();
    };

    return App;

  })();

  ai = {};

  ai.read = function(gamestate) {
    var e, error, len, result;
    try {
      len = gamestate.length - 1;
      result = {};
      result.corners = {
        "0-0": {
          'status': gamestate[0][0],
          "pos": [0, 0]
        },
        "0-max": {
          'status': gamestate[0][len],
          'pos': [0, len]
        },
        "max-max": {
          'status': gamestate[len][len],
          'pos': [len, len]
        },
        "max-0": {
          'status': gamestate[len][0],
          'pos': [len, 0]
        }
      };
      return result.points = {
        self: ptIndex(gamestate, game.players.ai),
        opponent: ptIndex(gamestate, game.players.human)
      };
    } catch (error) {
      e = error;
      console.error(e);
      return console.log(gamestate);
    }
  };

  ai["eval"] = function(input) {
    var j, k, key, l, len1, len2, len3, pos, pt, ref, surround, value;
    ref = input.corners;
    for (value = j = 0, len1 = ref.length; j < len1; value = ++j) {
      key = ref[value];
      if (value.status === 'unclaimed') {
        return value.pos;
      }
    }
    if (getRandInt(1, 2) === 1) {
      pt = input.points.self[getRandInt(0, input.points.self.length)];
      surround = ptsAroundpt(pt);
      for (k = 0, len2 = surround.length; k < len2; k++) {
        pos = surround[k];
        if (game.state[getX(pos)][getY(pos)] === 'unclaimed') {
          return pos;
        }
      }
    } else {
      pt = input.points.opponent[getRandInt(0, input.points.opponent.length)];
      surround = ptsAroundpt(pt);
      for (l = 0, len3 = surround.length; l < len3; l++) {
        pos = surround[l];
        if (game.state[getX(pos)][getY(pos)] === 'unclaimed') {
          return pos;
        }
      }
    }
  };

  ai.respond = function(grd) {
    var choose, chose_cell, state;
    state = getCurrentState(grd);
    if (game.players.ai === "X") {
      if ((game.turns % 2) !== 0) {
        choose = ai["eval"](state);
        chose_cell = grd.rows[getX(choose)].cells[getY(choose)];
        chose_cell.status = "X";
        $("#cell-" + chose_cell.row + "-" + chose_cell.col + "-img").attr('src', x_path);
        return game.turns = game.turns + 1;
      }
    } else if (game.players.ai === "O") {
      if ((game.turns % 2) === 0) {
        choose = ai["eval"](state);
        chose_cell = grd.rows[getX(choose)].cells[getY(choose)];
        chose_cell.status = "O";
        $("#cell-" + chose_cell.row + "-" + chose_cell.col + "-img").attr('src', o_path);
        return game.turns = game.turns + 1;
      }
    }
  };

  menu = new App("#app");

  menu.render();

}).call(this);
